{"version":3,"file":"437.js","mappings":"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","sources":["webpack:///../node_modules/@pixi/math-extras/dist/esm/math-extras.mjs"],"sourcesContent":["/*!\n * @pixi/math-extras - v6.5.10\n * Compiled Thu, 06 Jul 2023 15:25:11 UTC\n *\n * @pixi/math-extras is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Point, ObservablePoint, Rectangle } from '@pixi/math';\n\nvar mixins = {\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method add\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The point to add to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method add\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The point to add to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    add: function (other, outPoint) {\n        if (!outPoint) {\n            outPoint = new Point();\n        }\n        outPoint.x = this.x + other.x;\n        outPoint.y = this.y + other.y;\n        return outPoint;\n    },\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method subtract\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The point to subtract to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method subtract\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The point to subtract to `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    subtract: function (other, outPoint) {\n        if (!outPoint) {\n            outPoint = new Point();\n        }\n        outPoint.x = this.x - other.x;\n        outPoint.y = this.y - other.y;\n        return outPoint;\n    },\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiply\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The point to multiply with `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiply\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The point to multiply with `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    multiply: function (other, outPoint) {\n        if (!outPoint) {\n            outPoint = new Point();\n        }\n        outPoint.x = this.x * other.x;\n        outPoint.y = this.y * other.y;\n        return outPoint;\n    },\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiplyScalar\n     * @memberof PIXI.Point#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method multiplyScalar\n     * @memberof PIXI.ObservablePoint#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    multiplyScalar: function (scalar, outPoint) {\n        if (!outPoint) {\n            outPoint = new Point();\n        }\n        outPoint.x = this.x * scalar;\n        outPoint.y = this.y * scalar;\n        return outPoint;\n    },\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method dot\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method dot\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    dot: function (other) {\n        return (this.x * other.x) + (this.y * other.y);\n    },\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method cross\n     * @memberof PIXI.Point#\n     * @param {IPointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method cross\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    cross: function (other) {\n        /*\n         * Returns the magnitude of the vector that would result\n         * from a regular 3D cross product of the input vectors,\n         * taking their Z values implicitly as 0\n         * (i.e. treating the 2D space as a plane in the 3D space).\n         * The 3D cross product will be perpendicular to that plane,\n         * and thus have 0 X & Y components\n         * (thus the scalar returned is the Z value of the 3D cross product vector).\n         */\n        return (this.x * other.y) - (this.y * other.x);\n    },\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method normalize\n     * @memberof PIXI.Point#\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The normalized point.\n     */\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method normalize\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The normalized point.\n     */\n    normalize: function (outPoint) {\n        if (!outPoint) {\n            outPoint = new Point();\n        }\n        var magnitude = Math.sqrt((this.x * this.x) + (this.y * this.y));\n        outPoint.x = this.x / magnitude;\n        outPoint.y = this.y / magnitude;\n        return outPoint;\n    },\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitude\n     * @memberof PIXI.Point#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitude\n     * @memberof PIXI.ObservablePoint#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    magnitude: function () {\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\n    },\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitudeSquared\n     * @memberof PIXI.Point#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method magnitudeSquared\n     * @memberof PIXI.ObservablePoint#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    magnitudeSquared: function () {\n        return (this.x * this.x) + (this.y * this.y);\n    },\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method project\n     * @memberof PIXI.Point#\n     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `this` on `onto` projection.\n     */\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method project\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The `this` on `onto` projection.\n     */\n    project: function (onto, outPoint) {\n        if (!outPoint) {\n            outPoint = new Point();\n        }\n        // Math says: a Projected over b = [(a·b) / (b·b)] * b;\n        var normalizedScalarProjection = ((this.x * onto.x) + (this.y * onto.y)) / ((onto.x * onto.x) + (onto.y * onto.y));\n        outPoint.x = onto.x * normalizedScalarProjection;\n        outPoint.y = onto.y * normalizedScalarProjection;\n        return outPoint;\n    },\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method reflect\n     * @memberof PIXI.Point#\n     * @param {IPointData} normal - The normal vector of your reflecting plane.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The reflection of `this` on your reflecting plane.\n     */\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **@pixi/math-extras**._\n     * @method reflect\n     * @memberof PIXI.ObservablePoint#\n     * @param {IPointData} normal - The normal vector of your reflecting plane.\n     * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {IPointData} The reflection of `this` on your reflecting plane.\n     */\n    reflect: function (normal, outPoint) {\n        if (!outPoint) {\n            outPoint = new Point();\n        }\n        // Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n\n        var dotProduct = (this.x * normal.x) + (this.y * normal.y);\n        outPoint.x = this.x - (2 * dotProduct * normal.x);\n        outPoint.y = this.y - (2 * dotProduct * normal.y);\n        return outPoint;\n    }\n};\nObject.assign(Point.prototype, mixins);\nObject.assign(ObservablePoint.prototype, mixins);\n\n/**\n * Determines whether the `other` Rectangle is contained within `this` Rectangle object.\n * Rectangles that occupy the same space are considered to be containing each other.\n * Rectangles without area (width or height equal to zero) can't contain anything,\n * not even other arealess rectangles.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @method containsRect\n * @memberof PIXI.Rectangle#\n * @param {Rectangle} other - The Rectangle to fit inside `this`.\n * @returns {boolean} A value of `true` if `this` Rectangle contains `other`; otherwise `false`.\n */\nRectangle.prototype.containsRect = function containsRect(other) {\n    if (other.width <= 0 || other.height <= 0) {\n        return other.x > this.x && other.y > this.y && other.right < this.right && other.bottom < this.bottom;\n    }\n    return other.x >= this.x && other.y >= this.y && other.right <= this.right && other.bottom <= this.bottom;\n};\n/**\n * Accepts `other` Rectangle and returns true if the given Rectangle is equal to `this` Rectangle.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @method equals\n * @memberof PIXI.Rectangle#\n * @param {Rectangle} other - The Rectangle to compare with `this`\n * @returns {boolean} Returns true if all `x`, `y`, `width`, and `height` are equal.\n */\nRectangle.prototype.equals = function equals(other) {\n    if (other === this) {\n        return true;\n    }\n    return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n};\n/**\n * If the area of the intersection between the Rectangles `other` and `this` is not zero,\n * returns the area of intersection as a Rectangle object. Otherwise, return an empty Rectangle\n * with its properties set to zero.\n * Rectangles without area (width or height equal to zero) can't intersect or be intersected\n * and will always return an empty rectangle with its properties set to zero.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @method intersection\n * @memberof PIXI.Rectangle#\n * @param {Rectangle} other - The Rectangle to intersect with `this`.\n * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n * optional (otherwise will create a new Rectangle).\n * @returns {Rectangle} The intersection of `this` and `other`.\n */\nRectangle.prototype.intersection = function intersection(other, outRect) {\n    if (!outRect) {\n        outRect = new Rectangle();\n    }\n    var x0 = this.x < other.x ? other.x : this.x;\n    var x1 = this.right > other.right ? other.right : this.right;\n    if (x1 <= x0) {\n        outRect.x = outRect.y = outRect.width = outRect.height = 0;\n        return outRect;\n    }\n    var y0 = this.y < other.y ? other.y : this.y;\n    var y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n    if (y1 <= y0) {\n        outRect.x = outRect.y = outRect.width = outRect.height = 0;\n        return outRect;\n    }\n    outRect.x = x0;\n    outRect.y = y0;\n    outRect.width = x1 - x0;\n    outRect.height = y1 - y0;\n    return outRect;\n};\n/**\n * Adds `this` and `other` Rectangles together to create a new Rectangle object filling\n * the horizontal and vertical space between the two rectangles.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @method union\n * @memberof PIXI.Rectangle#\n * @param {Rectangle} other - The Rectangle to unite with `this`.\n * @param {Rectangle} [outRect] - A Rectangle object in which to store the value,\n * optional (otherwise will create a new Rectangle).\n * @returns {Rectangle} The union of `this` and `other`.\n */\nRectangle.prototype.union = function union(other, outRect) {\n    if (!outRect) {\n        outRect = new Rectangle();\n    }\n    var x1 = Math.min(this.x, other.x);\n    var x2 = Math.max(this.x + this.width, other.x + other.width);\n    var y1 = Math.min(this.y, other.y);\n    var y2 = Math.max(this.y + this.height, other.y + other.height);\n    outRect.x = x1;\n    outRect.y = y1;\n    outRect.width = x2 - x1;\n    outRect.height = y2 - y1;\n    return outRect;\n};\n\nfunction floatEqual(a, b, epsilon) {\n    if (epsilon === void 0) { epsilon = Number.EPSILON; }\n    if (a === b) {\n        return true;\n    }\n    var diff = Math.abs(a - b);\n    return diff < epsilon;\n}\n/**\n * Generic line or segment intersection.\n * A line can intersect outside the two points defining it, the segment can't.\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @param isLine - Set to true if you want Line (unbounded) intersection.\n * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the lines/segments intersect or a `NaN` Point.\n */\nfunction genericLineIntersection(aStart, aEnd, bStart, bEnd, isLine, outPoint) {\n    if (!outPoint) {\n        outPoint = new Point();\n    }\n    var dxa = aEnd.x - aStart.x;\n    var dya = aEnd.y - aStart.y;\n    var dxb = bEnd.x - bStart.x;\n    var dyb = bEnd.y - bStart.y;\n    // In order to find the position of the intersection in respect to the line segments, we can define lines\n    // in terms of first degree Bézier parameters, and find the two parameters `ua` and `ub` for the two lines to touch.\n    // both `ua` and `ub` formula share the same denominator so it is only calculated once.\n    var denominator = ((dyb * dxa) - (dxb * dya));\n    // If lines are parallel or overlapping, the intersection can be nowhere or everywhere... NaN.\n    if (floatEqual(denominator, 0)) {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n        return outPoint;\n    }\n    // ua is the factor of line a where the intersection occurs. ub is the factor of line b where the intersection occurs.\n    var ua = ((dxb * (aStart.y - bStart.y)) - (dyb * (aStart.x - bStart.x))) / denominator;\n    var ub = ((dxa * (aStart.y - bStart.y)) - (dya * (aStart.x - bStart.x))) / denominator;\n    // Line intersection extends beyond the bounds of the segment.\n    // The intersection is inside the segments if 0.0 ≤ ua ≤ 1.0 and 0.0 ≤ ub ≤ 1.0\n    if (!isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1)) {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n        return outPoint;\n    }\n    outPoint.x = aStart.x + (ua * dxa);\n    outPoint.y = bStart.y + (ub * dyb);\n    return outPoint;\n}\nfunction lineIntersection(aStart, aEnd, bStart, bEnd, outPoint) {\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, true, outPoint);\n}\nfunction segmentIntersection(aStart, aEnd, bStart, bEnd, outPoint) {\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, false, outPoint);\n}\n\nexport { floatEqual, lineIntersection, segmentIntersection };\n//# sourceMappingURL=math-extras.mjs.map\n"],"names":["mixins","add","other","outPoint","x","this","y","subtract","multiply","multiplyScalar","scalar","dot","cross","normalize","magnitude","Math","sqrt","magnitudeSquared","project","onto","normalizedScalarProjection","reflect","normal","dotProduct","floatEqual","a","b","epsilon","Number","EPSILON","abs","genericLineIntersection","aStart","aEnd","bStart","bEnd","isLine","dxa","dya","dxb","dyb","denominator","NaN","ua","ub","lineIntersection","segmentIntersection","Object","assign","prototype","containsRect","width","height","right","bottom","equals","intersection","outRect","x0","x1","y0","y1","union","min","x2","max","y2"],"sourceRoot":""}